'grep/grepl(pattern, vector)'),
Description = c('Concatenation of x and y.',
'Split a string by a splitting character.',
'Substitute a portion of a string vector based on a given pattern.',
'Pattern match a string and output its position OR Boolean (i.e. TRUE/FALSE).'),
Example = c("paste('a', 'b'); paste0('a', 'b')",
"x <- c('This is a sentence.',
'This is another sentence.',
'This is yet another sentence.')
\n strsplit(x, split = ' ')",
"gsub('sentence', 'drink', x)",
"grep('^M', rownames(mtcars), value = TRUE)"))
summ(summ_strings, 'Summary of String Functions')
x <- 2
if (x == 2) {
'x is 2!'
} else if (x == 3) {
'x is 3!'
} else {
'x is not 2 nor 3!'
}
x <- c(1:10)
# If x is divisible by 2, then "even"; else, "odd."
ifelse(x %% 2 == 0, paste0(x, ': even'), paste0(x, ': odd'))
# Getting the means for each column in mtcars.
## Create an empty vector into which we will
##   store means.
x <- c()
## For each variable in mtcars...
for (i in seq_along(mtcars)) {
### Store the mean of that variable
###   into x.
x[i] <- mean(mtcars[, i])
}
x
# set 4x3 canvas
par(mfrow = c(2, 3))
# For each column in the dataset iris...
for (i in seq_along(iris)) {
# Plot a histogram.
hist(mtcars[, i], # Get column vector.
xlab = names(iris)[i], # Get name of column.
ylab = 'Frequency',
col  = 'cyan4',
# Set the title to be based on the column name.
main = paste(names(iris[i]), 'Distribution'))
}
# Set an initial value for the while loop.
x <- 0
# While x is less than 10...
while (x < 10) {
# Add 1 to it...
x <- x + 1
# And then print it to the console.
print(x)
}
funs <- data.frame(`Statement or Function` = c('if (condition) {output}',
'ifelse(test, yes, no)',
'for (statement) {output}',
'while (condition) {output}'),
Description = c("Control the flow of the R script.",
"Control the flow of a vector.",
"Iterate over each data element.",
"Iterate over data until a condition breaks."),
Example = c("if (x == 2) {'x is 2!'} else {'x is not 2!'}",
"ifelse(1:10 %% 2 == 0, 'even', 'odd')",
"x <- c();
for (i in seq_along(mtcars)) {
x[i] <- mean(mtcars[, i])
};
x",
"x <- 0;
while (x < 10) {
x <- x + 1
print(x)
}"))
summ_funs <- summ(funs, caption = 'Control Flow Statements')
summ_funs
funs <- data.frame(Function = c('mean(x)',
'median(x)',
'min(x)',
'max(x)',
'nrow(x)/NROW(x)',
'ncol(x)/NCOL(x)',
'dim(x)',
'summary(x)',
'table(x)',
'prop.table(table)'),
Description = c('Computes the mean.',
'Computes the median.',
'Computes the minimum.',
'Computes the maximum.',
'Computes the number of rows.',
'Computes the number of columns.',
'Computes the number of rows and columns.',
'Summarizes a dataset.',
'Generates a frequency table for one or more variables.',
'Generates a proportions table.'),
Example     = c('mean(mtcars\\$mpg)',
'median(mtcars\\$mpg)',
'min(mtcars\\$mpg)',
'max(mtcars\\$mpg)',
'nrow(mtcars); NROW(mtcars)',
'ncol(mtcars); NCOL(mtcars)',
'dim(mtcars)',
'summary(mtcars)',
'table(mtcars\\$gear); with(mtcars, table(gear, am))',
'prop.table(table(mtcars\\$gear))'))
summ_funs <- summ(funs, caption = 'Summary of Descriptive Statistics Functions')
summ_funs
set.seed(1) # Remember our random numbers
x <- rnorm(100,       # 100 random numbers
mean = 50, # with a mean of 50
sd = 20)   # and SD of 20.
plot(density(x),
main = '100 Random Numbers')
set.seed(1) # Remember our random values.
# 10 random numbers from
#   a vector of 100 values.
sample(1:100, size = 10, replace = TRUE)
set.seed(1) # Remember our random values.
# Random 5 rows
mtcars[sample(1:NROW(mtcars), 5), ]
summ_pd <- data.frame(Function = c("rnorm(x)",
"sample(x, size)",
"Other probability functions."),
Description = c("x random numbers based on a normal distribution.",
"Sample a vector with a specified size.",
"See `?rnorm`, `?rchisq`, and `?rpois`"),
Example = c("rnorm(10)",
"sample(1:100, size = 10)",
""))
summ(summ_pd, 'Summary of Probability Distributions')
index <- function(x) { # the formals/arguments
x/mean(x) # The body
}
index(mtcars$mpg)
# Get only a few rows.
head(sapply(mtcars, index))
index2 <- function(x, f) {
x/f(x)
}
head(index2(mtcars$mpg, mean)) # show only a few elements
head(index2(mtcars$mpg, median)) # show only a few elements
head(index2(mtcars$mpg, max)) # show only a few elements
summ_fun <- data.frame(Function = c("function(x)"),
Description = c("Write a function, which consists of arguments and the body."),
Example = c("index <- function(x) x/mean(x)"))
summ(summ_fun, "Summary of Function Writing")
lapply(mtcars, mean)
sapply(mtcars, mean)
# Row-wise means.
# show only a few with head().
head(apply(mtcars, 1, mean))
# Column-wise means.
apply(mtcars, 2, mean)
# Mean of all mtcars columns
# Type-check whether it is a numeric vector.
vapply(mtcars, mean, numeric(1))
# Mean of all mtcars columns
# Type-check whether it is a character vector.
vapply(mtcars, mean, character(1))
mapply(mean, mtcars)
head(Map(mean, mtcars)) # Just show a few.
# Row bind mpg and wt from mtcars.
# Output = matrix
# Show only a few columns.
mapply(rbind, mtcars$mpg, mtcars$wt)[, 1:5]
# Row bind mpg and wt from mtcars.
# Output = list.
# Show only a few rows.
head(Map(rbind, mtcars$mpg, mtcars$wt))
my_list <- list(mtcars, airquality, iris)
rapply(my_list, # For this list...
# Get all means...
mean,
# Remove missing values...
na.rm = TRUE,
# Calculate only for numeric columns
classes = 'numeric')
# Ge thte mean MPG by gear and am.
my_agg <- aggregate(mpg ~ gear + am, mtcars, mean)
my_agg
funs <- data.frame(Function = c('lapply(X, FUN)',
'sapply(X, FUN)',
'apply(X, MARGIN, FUN)',
'vapply(X, FUN, FUN.VALUE)',
'mapply(FUN, ...)',
'Map(FUN, ...)',
'eapply(env, FUN)',
'rapply(object, f, classes)',
'aggregate(formula, data, FUN)'),
Description = c('Compute a function over data and output a list.',
'Compute a function over data and output a matrix (sometimes a list, depending on the function being passed).',
'Compute a function row-wise or column-wise.',
'Compute a function over data and output an array of a pre-specified type.',
'Compute a function over one or more data inputs and output an array (vector or matrix).',
'Compute a function over one or more data inputs and output a list.',
'Compute a function that affects the environment.',
'Recursively compute a function over data and output a vector or list.',
'Generate grouped computations and output a data frame.'),
Example     = c('lapply(mtcars, mean)',
'sapply(mtcars, mean)',
'apply(mtcars, 1, mean); apply(mtcars, 2, mean)',
'vapply(mtcars, mean, numeric(1))',
'mapply(rbind, mtcars\\$mpg, mtcars\\$wt)',
'Map(rbind, mtcars\\$mpg, mtcars\\$wt)',
'See ?eapply',
'rapply(iris, mean, classes = "numeric")',
'aggregate(mpg ~ gear, mtcars, mean)'))
summ_funs <- summ(funs, caption = 'Summary of Functionals')
summ_funs
hist(mtcars$mpg,
col = 'cyan4',
xlab = 'MPG',
ylab = 'Frequency',
main = 'MPG Distribution')
set.seed(1) # Remember our random numbers.
x <- density(rnorm(100))
plot(x,
main = '100 Random Numbers',
col  = 'salmon')
# Draw the scatter plot
with(mtcars,
plot(mpg ~ wt,
ylab = 'MPG',
xlab = 'Weight',
main = 'MPG vs. Weight',
col = 'cyan4',
pch = 16)) # pch determines point type.
# Draw a trend line over the scatter plot
abline(lm(mpg ~ wt, mtcars),
col = 'salmon',
lwd = 2) # line width
# Set up a 2x2 canvas
par(mfrow = c(2,2))
# Set parameters
unique_gears <- sort(unique(mtcars$gear))
mycolors <- c('cyan4', 'salmon','forestgreen', 'purple')
# Begin plot loop
for (i in seq_along(unique_gears)) {
# Subset by number of gears
ss <- subset(mtcars, gear == unique_gears[i])
# Plot a scatter points
with(ss,
plot(mpg ~ wt,
col = mycolors[i],
ylab = 'MPG',
xlab = 'Weight',
main = paste0('MPG vs. Weight (No. of Gears = ',
unique_gears[i],
')')))
# Generate a trendline for each subset.
abline(lm(mpg ~ wt, ss))
}
# Set up basic plot.
with(mtcars, plot(wt ~ mpg, pch = 1, type = 'n',
xlab = 'MPG',
ylab = 'Weight',
main = 'Weight vs. MPG'))
# Plot the labels on the graph.
with(mtcars, text(mpg, # x coordinate for words
wt,  # y coordinate for words
row.names(mtcars), # Words to use.
pos = 3,
cex = 0.0,
col = 'cyan4'))
# Add some mean lines for flair.
abline(h = mean(mtcars$wt), v = mean(mtcars$mpg),
lty = 2)
# Suppose we had this dataset:
set.seed(1) # Remember our random numbers.
df <- data.frame(y = rnorm(10),
x = 2000:2009)
# Plot this dataset
with(df, plot(y ~ x,
type = 'l',
col = 'salmon',
ylab = 'Some Random Numbers',
xlab = 'Year'))
with(mtcars,
boxplot(mpg ~ gear,
ylab = 'MPG',
xlab = 'Number of Gears',
main = 'Box Plot of MPG vs. Number of Gears',
col  = 'grey'))
my_table <- table(mtcars$gear)
barplot(my_table,
ylab = 'Frequency',
xlab = 'Number of Gears',
col  = 'lavender',
main = 'Frequencies by Number of Gears')
my_agg <- aggregate(mpg ~ gear, mtcars, mean)
with(my_agg,
barplot(mpg ~ gear, beside = TRUE,
ylab = 'Mean MPG',
xlab = 'Number of Gears',
main = 'Mean MPG by Number of Gears',
col  = 'lavender'))
funs <- data.frame(Function = c('hist(x)',
'plot(density(x))',
'plot(y ~ x)',
"plot(y ~ x, type = 'l')",
'boxplot(y ~ x)',
'barplot(x)'),
Input       = c('vector',
'density',
'formula (of vectors)',
'formula (of vectors)',
'formula (of vectors)',
'vector OR table'),
Description = c('Histogram',
'Density plot',
'Scatter plot',
'Line plot',
'Box plot',
'Bar plot'),
Example     = c('hist(mtcars\\$mpg)',
'plot(density(rnorm(100)))',
'with(mtcars, plot(mpg ~ wt))',
"with(Orange, plot(circumference ~ age, type = 'l'))",
'with(mtcars, boxplot(mpg ~ wt))',
'barplot(table(mtcars\\$gear))'))
summ_funs <- summ(funs, caption = 'Summary of Plotting Functions')
summ_funs
# Testing whether the mean MPG is statistically equal to 17.
t.test(mtcars$mpg, mu = 17)
# Compare mean MPG by transmission type
with(mtcars, t.test(mpg ~ am))
mytable <- with(mtcars, table(gear, am))
mytable
chisq.test(mytable)
summ_tests <- data.frame(Function = c('t.test(x, mu)',
't.test(y ~ x)',
'chisq.test(table)'),
Description = c('Test of mean against mu.',
'Test of group means.',
'Test of two-way frequencies.'),
Example = c('t.test(mtcars$mpg, mu = 17)',
'with(mtcars, t.test(mpg ~ am))',
'with(mtcars, chisq.test(table(gear, am)))'))
summ(summ_tests, 'Summary of Hypothesis Testing')
# Pearson correlation coefficient matrix
cor(mtcars)
# Pearson correlation coefficient test
with(mtcars, cor.test(mpg, wt))
# Load the library into the environment.
library(Hmisc)
my_corr <- rcorr(as.matrix(mtcars), type = 'pearson')
# Pearson correlation coefficients
my_corr$r
# p-values of the coefficients.
my_corr$P
my_anova <- aov(mpg ~ factor(gear) + factor(am), mtcars)
my_anova
summary(my_anova)
TukeyHSD(my_anova)
# SYNTAX OF lm(): lm(y ~ x1 + x2 + ... xn, data)
my_ols <- lm(mpg ~ wt + hp + gear + am, mtcars)
# Return the coefficients
my_ols
# Produce a summary table of the results.
summary(my_ols)
# Return the coefficient table from the summary regression table.
coef(summary(my_ols))
fit <- predict(my_ols)
res <- resid(my_ols)
plot(res ~ fit)
abline(lm(res ~ fit), lty = 2)
# Load libraries
library(knitr)
library(kableExtra)
# Let's do it again but with transform().
mydata2 <- transform(mydata, my_new_var = mpg/wt)
mydata <- mtcars # copy data
# Let's create a variable called "my_new_var"
mydata$my_new_var <- with(mtcars, mpg/wt)
# Let's do it again but with transform().
mydata2 <- transform(mydata, my_new_var = mpg/wt)
head(mydata)
# Let's do it again but with transform().
mydata2 <- transform(mydata, my_new_var = mpg/wt)
head(mydata2$my_new_var)
mydata <- mtcars # copy data
# Let's create a variable called "my_new_var"
mydata$my_new_var <- with(mtcars, mpg/wt)
head(mydata$my_new_var)
mydata$my_new_var <- NULL
head(mydata)
x <- 'Albatross'
substr(x, 1, 4)
substr(x, 4) # Goes to the end by default
x <- 'Albatross'
substr(x, 1, 4)
substring(x, 4) # Goes to the end by default
x <- 'Albatross'
substr(x, 1, 4)
substring(x, 5) # Goes to the end by default
?tapply
aggregate
args(tapply)
tapply(mtcars$mpg, mtcars$am, mean)
aggregate(mpg ~ am, mean)
aggregate(mpg ~ am, mtcars, mean)
aggregate(mpg ~ am, mtcars, table)
aggregate(mpg ~ am, mtcars, length)
args(by)
by(mtcars$mpg, mtcars$am, mean)
?apply
args(mapply)
args(Map)
options
switch(mtcars$mpg, 0 = "auto", 1 = "manual")
switch(mtcars$mpg, `0` = "auto", `1` = "manual")
# Load libraries
library(knitr)
library(kableExtra)
switch(x, `0` = 1)
# SYNTAX OF switch():
## switch(x, old_value = "new value")
x <- 0
switch(x, `0` = 1)
# SYNTAX OF switch():
## switch(x, old_value = "new value")
x <- 0
switch(x, `0` = 1)
switch(x, `0` = 1)
x
switch(x, 0 = 1)
?switch
# SYNTAX OF switch():
## switch(x, old_value = "new value")
x <- "a"
switch(x, a = 1)
x
rcauchy(10)
centre <- function(x, type) {
switch(type,
mean = mean(x),
median = median(x),
trimmed = mean(x, trim = .1))
}
x <- rcauchy(10)
centre(x, "mean")
x
centre(x, 'mean')
set.seed(1) # Remember our random sampling
my_vector <- c('Asian', 'African American', 'White')
my_vector2 <- sample(my_vector, 20, replace = TRUE)
my_vector2
my_vector2
set.seed(1) # Remember our random sampling
my_vector <- c('Asian', 'African American', 'White', 'Other')
my_vector2 <- sample(my_vector, 20, replace = TRUE)
my_vector2
set.seed(1) # Remember our random sampling
my_vector <- c('Asian', 'African American', 'White', 'Other')
my_vector2 <- sample(my_vector, 20, replace = TRUE)
my_vector2
set.seed(2) # Remember our random sampling
my_vector <- c('Asian', 'African American', 'White', 'Other')
my_vector2 <- sample(my_vector, 20, replace = TRUE)
my_vector2
set.seed(1) # Remember our random sampling
my_vector <- c('Asian', 'African American', 'White', 'Other')
my_vector2 <- sample(my_vector, 20, replace = TRUE)
my_vector2
my_switch <- function(v) {
switch(v, White = 0, `African American` = 1, Asian = 2, Other = 3)
}
sapply(my_vector2, my_switch)
sapply(my_vector2, my_switch) %>% as.data.frame
as.data.frame(sapply(my_vector2, my_switch))
split(mtcars, mtcars$gear)
by(mtcars, mtcars$gear, mean)
by(mtcars$mpg, mtcars$gear, mean)
tapply(mtcars$mpg, mtcars$gear, max)
my_split <- split(mtcars, mtcars$gear)
my_models <- lapply(my_split, function(data) lm(mpg ~ wt, data))
my_models
my_split <- split(mtcars, mtcars$gear)
my_models <- lapply(my_split, function(data) lm(mpg ~ wt, data))
my_models
sapply(my_models, coef)
?<
?`<`
?Comparison
x <- -10:10
x
x[x < 0] # same as subset(x, x < 0)
?`&`
?`in`
?`%in%`
x[x %in% 1:5]
subset(mtcars, mpg > 20)
subset(mtcars, mpg > 30)
subset(mtcars, mpg > 30 & wt > 1.6)
subset(mtcars, mpg > 30)
subset(mtcars, mpg > 30 & wt > 1.6)
subset(mtcars, mpg > 30 & wt > 1.7)
dotplot
barplot(tapply(mtcars$mpg, mtcars$am))
barplot(tapply(mtcars$mpg, mtcars$am, mean))
my_agg <- aggregate(mpg ~ am, mtcars, mean)
with(my_agg, barplot(mpg ~ am))
bookdown::publish_book(render = 'local')
devtools::install_github('rstudio/bookdown')
bookdown::publish_book(render = 'local')
bookdown::publish_book(render = 'local')
bookdown::publish_book(render = 'local')
bookdown::publish_book(render = 'local')
bookdown::publish_book(render = 'local')
